---
title: Worm; a technical writeup
date: 3/26/2025
---

A couple years ago, I had a lot of free time on my hands. And one of my favorite hobbies was tinkering with *nix systems to make myself a resource-efficent setup that worked perfectly for my workflow. Many in this world use tiling window managers like [i3](https://i3wm.org/) (or it's Wayland equivalent [sway](https://swaywm.org/)), etc; but I've never been a fan. They just don't work for me most of the time, although sometimes it's nice to have the option. I also wanted a window manager I could customize every aspect of exactly how I wanted, and one with customizable titlebars (a reparenting WM). So I set out to implement my own, and the fruit of that labour is [worm](https://github.com/codic12/worm). I'll go through why I made the technological choices I did and the overall architecture of the WM, though I won't go too into-detail into every bit of the code because it's a reasonably large codebase (several thousand lines).

## Why X11?
The new hype in the open source unix desktop world for a couple years is Wayland now; it's gotten to the point of mainstream adoption, where the two most used desktops (GNOME and KDE Plasma) both default to Wayland out of the box now. But Wayland is unfortunately a much harder platform to develop for. At the time, X11 worked flawlessly for my use cases and I didn't see a reason to make my life harder. That isn't to say that X11 doesn't have it's own issues; it is based on a fundamentally insecure model that doesn't hold up to scrutiny in 2025, it'll often tear (unless you have a compositor or the right graphics driver settings) etc etc; but at the time I wrote it, it *just worked* &trade;.

Now I had to choose a language and framework. Unlike Wayland, where a compositor is a window manager, compositor and the display server, the X11 protocol is implemented in modular layers that allow things to be different programs. At the core is the X11 server, which draws everything on a "display" with an ID like `:0` (for the first display). Upon this runs a window manager, which is merely a X11 client that intercepts when new windows are created and facilitates performing different actions on windows. A compositor (these are often combined with the window manager in DEs, for example in Gnome's mutter or KDE's kwin) allows fancier effects to be implemented by having windows render to an off-screen buffer and compositing these together; however we won't deal with that today, though `worm` is fully compatible with an external compositor of your choice.

## Why Nim/Xlib?
Initially, I started worm in Rust. There are two major C libraries used to interact with the X11 display server; `Xlib` and `xcb`. While wrappers to both libraries are available for Rust, they're rather unidiomatic and require using a lot of `unsafe` blocks which I think defeats the point of Rust for a project like this (considering the fact that it's not a large critical system but just one user program). So I used [x11rb](https://github.com/psychon/x11rb), which takes the XML protocol files that `xcb` is autogenerated from and generates an idiomatic Rust implementation of the protocol. The first prototype was a fully non-reparenting window manager; it had borders, but no titlebars. While it worked well, I wanted to add more features and while they were certainly doable in `x11rb`, examples were scarce on the internet (compared to `xlib`). Around this time, I became interested in another programming language that caught my eye; [Nim](https://nim-lang.org), so I switched to it (I had a lot of time to kill). Nim's a language a lot of people haven't heard of; it's a statically typed language that compiles to native executables using C as an intermediary. This makes it extremely portable, and I really enjoyed writing Worm in Nim; it was an opportunity to introduce myself to unique features of the language and overall made me a better programmer. 

## Development process
I started by porting the code of [tinyWM](http://incise.org/tinywm.html). It's a small window manager written in Xlib (under 50 lines!). To help better understand how a WM works, X11 is based on an event-based model and your WM is just a client in that system. As long as it's running, it waits for the next event and then does an appropriate action based on what that event is. Before you start listening to events, you choose which events you want to listen to by using bitwise operations on predefined mask constants. Also, the events you choose have to be on a specific window, although windows can have subwindows. For a WM, you're usually listening on the root window, and every other window is a subwindow of the root window. Once you understand this system, it's actually quite intuitive. If you want to read the code in detail, go to the tinyWM website and scroll down; you'll find a rather well annotated version. 

Worm is a reparenting window manager. Remember how I said each window was a subwindow of the root window? What a reparenting window manager does is essentially, for each new window that is created by a client:

1. construct another new window (same size, or slightly bigger to account for titlebar/etc)
2. "re-parent" the new window the person tried to create into the new window WE created (it's parent window will no longer be root but our new window)
3. customize the outer window we made however we want

I started worm as a single file. It was actually quite manageable at first and it's really nice to have everything in a small file, but I eventually [had to refactor it](https://github.com/codic12/worm/commit/563ae15e4081e2c94e4bfc864df6ce90b93f9c29) where I split it by putting each X11 event into a seperate file in the `events/` directory.

Worm is configured through an IPC-based system. This was inspired by sway/i3. You use the `wormc` client program (also contained in the source code repository)